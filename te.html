<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Document</title>
<style>
html,body{ margin: 0; padding: 0 }
</style>
</head>
<body>
<script>
const G_R = 2
const colors = [
  'rgba(244,14,14,1)',
  'rgba(14,244,14,1)',
  'rgba(14,14,244,1)',
  'rgba(244,14,244,1)',
  'rgba(14,244,244,1)',
  'rgba(244,244,14,1)',
  'rgba(222,128,44,1)',
  '#000',
  'rgba(244,14,14,.7)',
  'rgba(14,244,14,.7)',
  'rgba(14,14,244,.7)',
  'rgba(244,14,244,.7)',
  'rgba(14,244,244,.7)',
  'rgba(244,244,14,.7)',
  'rgba(222,128,44,.7)',
  '#888'
]
const radial = (c, i) => {
  const cvs = document.createElement('canvas')
  cvs.width = cvs.height = 10 * G_R
  const ctx = cvs.getContext('2d')
  ctx.fillStyle = '#999'
  ctx.beginPath()
  ctx.arc(5 * G_R, 5 * G_R, 5 * G_R, 0, Math.PI * 2, 1)
  ctx.closePath()
  ctx.fill()
  // const grad = ctx.createLinearGradient(0, 0, 10, 10)
  const grad = ctx.createRadialGradient(3 * G_R, 3 * G_R, 1 * G_R, 5 * G_R, 5 * G_R, 5 * G_R)
  grad.addColorStop(0, 'white')
  grad.addColorStop(1, colors[i])
  ctx.fillStyle = grad
  ctx.beginPath()
  ctx.arc(5 * G_R, 5 * G_R, 4.5 * G_R, 0, Math.PI * 2, 1)
  ctx.closePath()
  ctx.fill()
  // ctx.fillRect(1, 1, 7, 7)
  ctx.font = '12px monospace'
  ctx.fillStyle = '#000'
  ctx.fillText('ðŸ’—', 2 * G_R, 7 * G_R)
  colors[i] = ctx.createPattern(cvs, 'repeat')
}
const pat1 = (c, i) => {
  const cvs = document.createElement('canvas')
  cvs.width = cvs.height = 10 * G_R
  const ctx = cvs.getContext('2d')
  ctx.fillStyle = '#999'
  ctx.beginPath()
  ctx.rect(0, 0, 10 * G_R - 1, 10 * G_R - 1)
  ctx.closePath()
  ctx.fill()
  const grad = ctx.createLinearGradient(0, 0, 10, 10)
  // const grad = ctx.createRadialGradient(3 * G_R, 3 * G_R, 1 * G_R, 5 * G_R, 5 * G_R, 5 * G_R)
  grad.addColorStop(0, 'white')
  grad.addColorStop(1, colors[i])
  ctx.fillStyle = grad
  ctx.beginPath()
  ctx.rect(1 * G_R - 1, 1 * G_R - 1, 9 * G_R - 1, 9 * G_R - 1)
  ctx.closePath()
  ctx.fill()
  colors[i] = ctx.createPattern(cvs, 'repeat')
}
colors.forEach(pat1)
const set = [
  { data: 0 << 1 | 1, b: [ [ 33, 34, 35, 36 ], [ 04, 14, 24, 34 ] ] },
  { data: 1 << 1 | 1, b: [ [ 24, 25, 34, 35 ] ] },
  { data: 2 << 1 | 1, b: [ [ 26, 34, 35, 36 ], [ 14, 24, 34, 35 ], [ 34, 24, 25, 26 ], [ 15, 25, 35, 14 ] ] },
  { data: 3 << 1 | 1, b: [ [ 24, 34, 35, 36 ], [ 14, 24, 34, 15 ], [ 36, 24, 25, 26 ], [ 15, 25, 35, 34 ] ] },
  { data: 4 << 1 | 1, b: [ [ 25, 34, 35, 36 ], [ 25, 24, 14, 34 ], [ 35, 24, 25, 26 ], [ 24, 25, 15, 35 ] ] },
  { data: 5 << 1 | 1, b: [ [ 23, 24, 34, 35 ], [ 15, 24, 34, 25 ] ] },
  { data: 6 << 1 | 1, b: [ [ 25, 26, 34, 35 ], [ 14, 24, 25, 35 ] ] },
]
class Bo{
  constructor(){
    this.values = []

    const block = set[set.length * Math.random() | 0]
    let orientation = block.b.length * Math.random() | 0
    const setData = () => {
      const b = block.b[orientation]
      for(var i = 0; i < b.length; i ++){
        this.values[i] = b[i]
      }
    }
    Object.defineProperties(this, {
      orientation: { get: () => orientation }
    })
    setData()
    this.data = block.data
    this.cw = () => {
      orientation = (orientation + 1) % block.b.length
      setData()
    }
    this.ccw = () => {
      orientation = (orientation - 1 + block.b.length) % block.b.length
      setData()
    }
  }
}
class Te{
  constructor(){
    let buffer = this.buffer = new Array(1 << 8).fill(0)
    this.blocks = []
    this.holder = null
    this.b()
    let _x = 0, _y = 0, _score = 0

    const
      left_border = values => 0 - Math.min(values[0] % 10, values[1] % 10, values[2] % 10, values[3] % 10),
      right_border = values => 9 - Math.max(values[0] % 10, values[1] % 10, values[2] % 10, values[3] % 10)
    
    Object.defineProperties(this, {
      gameover: {
        get(){
          let over = 0
          for(let i = 0; i < 10; i ++){
            over |= this.buffer[i + 30]
          }
          return !!over
        }
      },
      block: {
        get: () => this.blocks[0]
      },
      score: { get(){ return _score } },
      x: {
        get(){ return _x },
        set: v => {
          if(!isNaN(v)){
            const { values } = this.block
            const left = left_border(values),
              right = right_border(values)
            
            _x = Math.max(left, Math.min(right, v))
          }
        }
      },
      y: {
        get(){ return _y },
        set: v => {
          if(!isNaN(v) && v >= 0 && v <= 20){
            _y = v
          }
        }
      }
    })

    const check = (x, y) => {
      const { buffer, block } = this
      const c = x + y * 10
      return block.values.some(i => buffer[i + c] & 1)
    }
    let eraseTime = null
    const erase = () => {
      clearTimeout(eraseTime)
      eraseTime = setTimeout(() => {
        const nbuffer = buffer.filter((b, i) => i >= 240 || !(b >> 7))
        const count = (0x100 - nbuffer.length) / 10
        while(nbuffer.length < 0x100){
          nbuffer.unshift(0)
        }
        buffer = this.buffer = nbuffer
        if(count){
          _score += (1 << count) - 1
          buffer[0xfc] = _score >> 24 & 0xff
          buffer[0xfd] = _score >> 16 & 0xff
          buffer[0xfe] = _score >> 8 & 0xff
          buffer[0xff] = _score & 0xff
        }
      }, 300)
      this.b()
    }
    const ping2 = () => {
      const { buffer } = this
      let bottom = 23, count = 0
      while(bottom >= 0){
        let pong = 1
        for(let i = 0; i < 10; i ++){
          pong &= buffer[i + bottom * 10]
        }
        if(pong){
          for(let i = 0; i < 10; i ++){
            buffer[i + bottom * 10] |= ((1 << 7) | (300 << 8))
          }
        }
        bottom --
      }
      erase()
    }
    const ping = () => {
      const { buffer } = this
      let bottom = 23, count = 0
      while(bottom >= 0){
        let pong = 1
        for(let i = 0; i < 10; i ++){
          pong &= buffer[i + bottom * 10]
        }
        if(pong){
          _score += 1 << count
          count ++
          let tail = bottom * 10 + 9
          while(tail > 9){
            buffer[tail] = buffer[tail - 10]
            tail --
          }
          while(tail > -1){
            buffer[tail] = 0
            tail --
          }
        }
        else{
          bottom --
        }
      }
      buffer[0xfc] = _score >> 24 & 0xff
      buffer[0xfd] = _score >> 16 & 0xff
      buffer[0xfe] = _score >> 8 & 0xff
      buffer[0xff] = _score & 0xff
      this.b()
    }
    
    this.left = () => {
      const ox = this.x
      this.x -= 1
      if(check(this.x, this.y)){
        this.x = ox
      }
      return ox !== this.x
    }
    this.right = () => {
      const ox = this.x
      this.x += 1
      if(check(this.x, this.y)){
        this.x = ox
      }
      return ox !== this.x
    }
    this.down = () => {
      if(!this.gameover){
        const { buffer, x, y, block } = this
        if(y === 20 || check(x, y + 1)){
          for(var i = 0; i < block.values.length; i ++){
            buffer[block.values[i] + x + y * 10] = block.data
          }
          this.blocks.shift()
          ping2()
        }
        else{
          this.y += 1
        }
      }
    }
    this.cw = () => {
      const { x, block } = this
      block.cw()
      this.x = x

      if(check(this.x, this.y)){
        if(this.left()){ return true }
        if(this.right()){ return true }
        block.ccw()
        this.x = x
        return false
      }
      return true
    }
    this.ccw = () => {
      const { x, block } = this
      block.ccw()
      this.x = x

      if(check(this.x, this.y)){
        if(this.left()){ return true }
        if(this.right()){ return true }
        block.cw()
        this.x = x
        return false
      }
      return true
    }
  }
  b(){
    while(this.blocks.length < 6){
      this.blocks.push(new Bo)
    }
    this.x = 0
    this.y = 0
  }
}

class TeRender{
  constructor(){
    this.t = new Te
    const canvas = this.canvas = document.createElement('canvas')
    canvas.width = 320 * G_R
    canvas.height = 320 * G_R
    canvas.style.cssText = 'width: 100vw; height: auto;'
    document.body.appendChild(canvas)
    this.ctx = canvas.getContext('2d')
    document.addEventListener('keypress', this)
    document.addEventListener('touchstart', this, true)

    this.render = this.render.bind(this)
    this.rafTimer = null
  }
  keyboardHandleEvent(e){
    const { t } = this
    switch(e.keyCode){
      case 97: return t.left()
      case 115:
        clearInterval(this.timer)
        this.timer = setInterval(() => t.down(), 1000)
        return t.down()
      case 100: return t.right()
      case 113: return t.ccw()
      case 101:
      case 119: return t.cw()
    }
  }
  touchstartHandleEvent(e){
    const { pageX, pageY } = e.changedTouches[0]
    this._ox = pageX
    this._oy = pageY
    this.allowControl = true
    document.documentElement.style.touchAction = 'none'
    document.addEventListener('touchmove', this, { passive: false })
    document.addEventListener('touchend', this, { passive: false })
    document.addEventListener('touchcancel', this, { passive: false })
  }
  touchmoveHandleEvent(e){
    if(this.allowControl){
      e.preventDefault()
      const { pageX, pageY } = e.changedTouches[0]
      const cx = pageX - this._ox, cy = pageY - this._oy,
        min_width = innerWidth / 10,
        min_height = innerHeight / 20

      if(Math.abs(cx) > min_width){
        let v = cx / min_width | 0
        this._ox += cx - cx % min_width
        while(v){
          if(v > 0){
            this.t.right()
            v --
          }
          else{
            this.t.left()
            v ++
          }
        }
      }

      if(Math.abs(cy) > min_height){
        let v = cy / min_height | 0
        this._oy += cy - cy % min_height
        while(v){
          if(v > 0){
            this.t.down()
            v --
          }
          else{
            this.t.cw()
            v ++
          }
        }
      }


    }
  }
  touchendHandleEvent(e){
    this.allowControl = false
    document.documentElement.style.touchAction = ''
    document.removeEventListener('touchmove', this, { passive: false })
    document.removeEventListener('touchend', this, { passive: false })
    document.removeEventListener('touchcancel', this, { passive: false })
  }
  handleEvent(e){
    switch(e.type){
      case 'keypress': return this.keyboardHandleEvent(e)
      case 'touchstart': return this.touchstartHandleEvent(e)
      case 'touchmove': return this.touchmoveHandleEvent(e)
      case 'touchend':
      case 'touchcancel': return this.touchendHandleEvent(e)
    }
  }
  start(){
    requestAnimationFrame(this.render)
    this.timer = setInterval(() => this.t.down(), 1000)
  }
  pause(){

  }
  resume(){

  }
  clear(){
    const { ctx } = this
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)
  }
  renderBlock(x, y, color, b){
    const { ctx } = this
    ctx.fillStyle = color
    ctx.fillRect((x * 10 + 110) * G_R, (y * 10 + 10) * G_R, 10 * G_R, 10 * G_R)
    if(b & (1 << 7)){
      const remain = b >> 8
      ctx.fillStyle = `rgba(255, 255, 255, ${ (300 - remain) / 300 })`
      ctx.fillRect((x * 10 + 110) * G_R, (y * 10 + 10) * G_R, 10 * G_R, 10 * G_R)
    }
  }
  renderBG(){
    const { ctx } = this
    ctx.fillStyle = '#ccc'
    ctx.fillRect(110 * G_R, 10 * G_R, 100 * G_R, 240 * G_R)
  }
  renderScore(){
    const { t, ctx } = this
    const { buffer } = t
    const score = buffer[0xfc] << 3 |
      buffer[0xfd] << 2 |
      buffer[0xfe] << 1 |
      buffer[0xff]
    
    ctx.font = '14px monospace'
    ctx.fillStyle = '#000'
    ctx.fillText(score, 200 * G_R, 300 * G_R)
  }
  renderQueueBlocks(){
    const { ctx, t } = this
    for(var i = 1; i < t.blocks.length; i ++) {
      const block = t.blocks[i]
      const color = colors[(block.data >> 1) & 7]
      for(var j = 0; j < block.values.length; j ++){
        const idx = block.values[j]
        this.renderBlock(idx % 10 + 10, (idx / 10 | 0) + (i - 1) * 5, color, block.data)
      }
    }
  }
  render(ts){
    this.timespan = this.pts ? ts - this.pts : 0
    this.clear()
    this.renderBG()
    this.renderQueueBlocks()
    this.renderScore()

    const { ctx, t } = this
    const { buffer, gameover } = t

    for(let i = 0; i < 240; i ++){
      const b = buffer[i]
      if(b & 1){
        if(b & (1 << 7)){
          let remain = Math.max(0, (b >> 8) - this.timespan)
          buffer[i] = b & 0xff | (remain << 8)
        }
        this.renderBlock(i % 10, i / 10 | 0, colors[((b >> 1) & 7) + 8], buffer[i])
      }
    }
    // if(!gameover){
      const { block, x, y } = t
      const color = colors[(block.data >> 1) & 7]
      for(var i = 0; i < block.values.length; i ++){
        const idx = (block.values[i] + x + y * 10)
        this.renderBlock(idx % 10, idx / 10 | 0, color, block.data)
      }
    // }
    this.pts = ts
    this.rafTimer = requestAnimationFrame(this.render)
  }
}

const game = new TeRender
game.start()

</script>
</body>
</html>
