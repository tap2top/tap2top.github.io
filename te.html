<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Document</title>
</head>
<body>
<script>
const colors = [
  'rgba(244,14,14,1)',
  'rgba(14,244,14,1)',
  'rgba(14,14,244,1)',
  'rgba(244,14,244,1)',
  'rgba(14,244,244,1)',
  'rgba(244,244,14,1)',
  'rgba(222,128,44,1)',
  '#000',
  'rgba(244,14,14,.7)',
  'rgba(14,244,14,.7)',
  'rgba(14,14,244,.7)',
  'rgba(244,14,244,.7)',
  'rgba(14,244,244,.7)',
  'rgba(244,244,14,.7)',
  'rgba(222,128,44,.7)',
  '#888'
]
colors.forEach((c, i) => {
  const cvs = document.createElement('canvas')
  cvs.width = cvs.height = 10
  const ctx = cvs.getContext('2d')
  ctx.fillStyle = '#999'
  ctx.fillRect(0, 0, 9, 9)
  const grad = ctx.createLinearGradient(0, 0, 10, 10)
  grad.addColorStop(0, 'white')
  grad.addColorStop(1, colors[i])
  ctx.fillStyle = grad
  ctx.fillRect(1, 1, 7, 7)
  colors[i] = ctx.createPattern(cvs, 'repeat')
})
const set = [
  { data: 0 << 1 | 1, b: [ [ 33, 34, 35, 36 ], [ 04, 14, 24, 34 ] ] },
  { data: 1 << 1 | 1, b: [ [ 24, 25, 34, 35 ] ] },
  { data: 2 << 1 | 1, b: [ [ 26, 34, 35, 36 ], [ 14, 24, 34, 35 ], [ 34, 24, 25, 26 ], [ 15, 25, 35, 14 ] ] },
  { data: 3 << 1 | 1, b: [ [ 24, 34, 35, 36 ], [ 14, 24, 34, 15 ], [ 36, 24, 25, 26 ], [ 15, 25, 35, 34 ] ] },
  { data: 4 << 1 | 1, b: [ [ 25, 34, 35, 36 ], [ 25, 24, 14, 34 ], [ 35, 24, 25, 26 ], [ 24, 25, 15, 35 ] ] },
  { data: 5 << 1 | 1, b: [ [ 23, 24, 34, 35 ], [ 15, 24, 34, 25 ] ] },
  { data: 6 << 1 | 1, b: [ [ 25, 26, 34, 35 ], [ 14, 24, 25, 35 ] ] },
]
class Bo{
  constructor(){
    this.values = []

    const block = set[set.length * Math.random() | 0]
    let orientation = block.b.length * Math.random() | 0
    const setData = () => {
      const b = block.b[orientation]
      for(var i = 0; i < b.length; i ++){
        this.values[i] = b[i]
      }
    }
    Object.defineProperties(this, {
      orientation: { get: () => orientation }
    })
    setData()
    this.data = block.data
    this.cw = () => {
      orientation = (orientation + 1) % block.b.length
      setData()
    }
    this.ccw = () => {
      orientation = (orientation - 1 + block.b.length) % block.b.length
      setData()
    }
  }
}
class Te{
  constructor(){
    this.buffer = new Uint8ClampedArray(1 << 8)
    this.blocks = []
    this.holder = null
    this.b()
    let _x = 0, _y = 0

    const
      left_border = values => 0 - Math.min(values[0] % 10, values[1] % 10, values[2] % 10, values[3] % 10),
      right_border = values => 9 - Math.max(values[0] % 10, values[1] % 10, values[2] % 10, values[3] % 10)
    
    Object.defineProperties(this, {
      gameover: {
        get(){
          let over = 0
          for(let i = 0; i < 10; i ++){
            over |= this.buffer[i + 30]
          }
          return !!over
        }
      },
      block: {
        get: () => this.blocks[0]
      },
      x: {
        get: () => _x,
        set: v => {
          if(!isNaN(v)){
            const { values } = this.block
            const left = left_border(values),
              right = right_border(values)
            
            _x = Math.max(left, Math.min(right, v))
          }
        }
      },
      y: {
        get: () => _y,
        set: v => {
          if(!isNaN(v) && v >= 0 && v <= 20){
            _y = v
          }
        }
      }
    })

    const check = (x, y) => {
      const { buffer, block } = this
      const c = x + y * 10
      return block.values.some(i => buffer[i + c] & 1)
    }
    const ping = () => {
      const { buffer } = this
      let bottom = 23
      while(bottom >= 0){
        let pong = 1
        for(let i = 0; i < 10; i ++){
          pong &= buffer[i + bottom * 10]
        }
        if(pong){
          let tail = bottom * 10 + 9
          while(tail > 9){
            buffer[tail] = buffer[tail - 10]
            tail --
          }
          while(tail > -1){
            buffer[tail] = 0
            tail --
          }
        }
        else{
          bottom --
        }
      }
      this.b()
    }
    
    this.left = () => {
      const ox = this.x
      this.x -= 1
      if(check(this.x, this.y)){
        this.x = ox
      }
      return ox !== this.x
    }
    this.right = () => {
      const ox = this.x
      this.x += 1
      if(check(this.x, this.y)){
        this.x = ox
      }
      return ox !== this.x
    }
    this.down = () => {
      if(!this.gameover){
        const { buffer, x, y, block } = this
        if(y === 20 || check(x, y + 1)){
          for(var i = 0; i < block.values.length; i ++){
            buffer[block.values[i] + x + y * 10] = block.data
          }
          this.blocks.shift()
          ping()
        }
        else{
          this.y += 1
        }
      }
    }
    this.cw = () => {
      const { x, block } = this
      block.cw()
      this.x = x

      if(check(this.x, this.y)){
        if(this.left()){ return true }
        if(this.right()){ return true }
        block.ccw()
        this.x = x
        return false
      }
      return true
    }
    this.ccw = () => {
      const { x, block } = this
      block.ccw()
      this.x = x

      if(check(this.x, this.y)){
        if(this.left()){ return true }
        if(this.right()){ return true }
        block.cw()
        this.x = x
        return false
      }
      return true
    }
  }
  b(){
    while(this.blocks.length < 4){
      this.blocks.push(new Bo)
    }
    this.x = 0
    this.y = 0
  }
}

class TeRender{
  constructor(){
    this.t = new Te
    const canvas = this.canvas = document.createElement('canvas')
    canvas.style.border = '1px solid red'
    canvas.width = 320
    canvas.height = 320
    document.body.appendChild(canvas)
    this.ctx = canvas.getContext('2d')
    document.addEventListener('keypress', this)

    this.render = this.render.bind(this)
    this._rafTimer = null
  }
  handleEvent(e){
    const { t } = this
    switch(e.keyCode){
      case 97: return t.left()
      case 115: return t.down()
      case 100: return t.right()
      case 113: return t.ccw()
      case 101:
      case 119: return t.cw()
    }
  }
  start(){
    this.render()
  }
  pause(){

  }
  resume(){

  }
  clear(){
    const { ctx } = this
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)
  }
  renderBlock(x, y, color){
    const { ctx } = this
    ctx.fillStyle = color
    ctx.fillRect(x * 10 + 10, y * 10 + 10, 10, 10)
  }
  renderBG(){
    const { ctx } = this
    ctx.fillStyle = '#ccc'
    ctx.fillRect(10, 10, 100, 240)
  }
  renderQueueBlocks(){
    const { ctx, t } = this
    t.blocks.forEach((block, i) => {
      for(var j = 0; j < block.values.length; j ++){
        this.renderBlock(idx % 10, idx / 10 | 0, color)
      }
    })
      const { block, x, y } = t
      const color = colors[(block.data >> 1) & 7]

  }
  render(){
    this.clear()
    this.renderBG()
    const { ctx, t } = this
    const { buffer, gameover } = t

    for(let i = 40; i < 240; i ++){
      const b = buffer[i]
      if(b & 1){
        this.renderBlock(i % 10, i / 10 | 0, colors[((b >> 1) & 7) + 8])
      }
    }
    if(!gameover){
      const { block, x, y } = t
      const color = colors[(block.data >> 1) & 7]
      for(var i = 0; i < block.values.length; i ++){
        const idx = (block.values[i] + x + y * 10)
        this.renderBlock(idx % 10, idx / 10 | 0, color)
      }
    }
    this.timer = requestAnimationFrame(this.render)
  }
}

const game = new TeRender
game.start()

</script>
</body>
</html>
